---
title: How to be Atcoder Green Level
date: '2021-09-10 00:00:00'
description: Python, Algorizm, Leetcode
category: Python
background: '#4169e1'
---

I finally got into the green at the ABC215 held the other day!
It has been a long road, taking more than a year, so here is a summary of my study process so far and my current specifications.

https://twitter.com/w2vw2vkk/status/1429082090184708096?s=20

<img width="700" alt="image.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/239544/d853989c-d900-192b-dc13-8f513bc1a8a0.png">

# Self Introduction

-   Web engineer, 2nd year
    -   Engaged in development and operation work at a web-based company.
-   Undergraduated in mechanical engineering, researched information retrieval and NLP after being assigned to a laboratory (at the 4th year of undergraduate school) and during the 2 years of master's degree.
    -   Received a JASSO scholarship waiver (half tuition) while studying for my master's degree.
    -   Undergraduates do not have a background in information science \*1
    -   1:To begin with, when I advanced to the second year of university, I was assigned to a major, but I didn't choose the informatics major because I had given up on it because I didn't have the aptitude for programming because everyone around me excelled in C language in the first class... (I ended up going around other engineers. (I went around and ended up becoming an engineer now...)
-   Obtained the Basic Information Technology Engineer Examination (2021/03)
-   I didn't major in information science when I was an undergraduate, but I had a master's degree in information science from a mechanical engineering department, and now I'm working as an engineer.

### Languages used in Atcoder

-   Java: before 2021/01
-   Python 3.8.1 (PyPy) after 2021/01

### Why did you start Atcoder in the first place?

-   I started Atcoder because my juniors in my lab and my classmates in my company (both excellent) were doing it when they were students (and they are all green coders). (And they are all green coders).
    -   I felt that if I had Atcoder green level skills, I would be able to guarantee a certain level of implementation skills in my career as an engineer.
-   I became aware of the importance of basic algorithmic skills.
    -   As mentioned above, I became acutely aware of the importance of basic CS skills during my research throughout my master's degree. (It changes the speed at which one can formulate an image path to solve a certain task...)　 I started Atcoder to improve my ability to implement basic algorithms, thinking that the first year or two of an engineer's career should be reserved for learning the basics, even if it means taking a few detours.
-   To get used to the Java language
    -   I participated in Java contests in the beginning to get used to Java quickly because it was the language I used in my work.

###### Why did you decide to continue playing Atcoder as a working adult?

Working people may have less time than undergraduates. The reasons why I continued to participate in Atcoder are as follows.

-   At first, I was just trying to get used to Java.
    -   As I solved problems, the more I tried, the more I got hooked, and participating in ABC on weekends and evenings became a habitual event.
-   I thought that I could learn not to do implementations that should not be done (without considering computation and memory usage), and that I could learn to code with an awareness of the load and amount of data when a large number of requests occur. I thought that I could learn to code with an awareness of the load and the amount of data when a large number of requests occur.
    -   As I solved the problems, I thought that it would lead to my ability in terms of coding speed and accuracy in my work.
        -   (I was a little conscious of whether the code I wrote would not cause problems when I had to migrate a large amount of data to production. (I did not use any special algorithm.)

# Learning contents used

Basically, I solved Atcoder's past problems. The main sources of information I used differed slightly depending on the period I wanted to improve.
I used these sites to select questions to solve. Just because I used them as my main source for a period of time does not mean that I did not use them outside of that period of time.

Solving past problems at #### [Atcoder Problems](https://kenkoooo.com/atcoder/#/table/) [2020/10 ~ 2021/02]

-   (Need I mention?) This was useful when I wanted to look at a list of questions from the past.
-   I solved the most recent past exam questions at the C and D level in order.
-   To be honest, I was more motivated to get used to Java than to get a good grade (so I chose Java as my language of choice).
-   (So I participated in Java as my language of choice.) There was a period during which I prioritized preparation for the Basic Information exam, so I don't think the amount of devotion was that great.
-   Around January 2021, I decided to shift completely to Python because I thought that Python is much more efficient for achieving high scores because I am familiar with it, it has a rich library, and it can be written simply.

###### Amount of devotion on the day I entered green

<img width="700" alt="image.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/239544/5c1f8c4a-e2ff-b71d-7652-db699c502dbe.png">
<img width="700" alt="image.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/239544/f7b6280f-a1c0-a84c-792e-f77fc783df14.png">
<img width="700" alt="image.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/239544/032af8c0-e94c-427d-da41-6bbe458eb002.png">
<img width="700" alt="image.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/239544/bd24e387-618a-b46c-47bb-c319910261d6.png">

###### Reference:[Atcoder Performances](https://atcoderapps.herokuapp.com/atcoderperformances/)

#### Atcoder Problems' [Training Features](https://kenkoooo.com/atcoder/#/training) [2020/03 ~ 2021/06]

<img width="700" alt="image.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/239544/f6878662-5ad4-9a4e-012f-2ef94fc1f4ae.png">

-   This is not a feature that has received much attention(?). Atcoder Problems has a training function. Personally, I have made great use of it.
-   There are three levels, Easy, Medium, and Hard, each consisting of 100 problems in gray, brown, and green, respectively. The difficulty level is sorted by Difficulty, so you can see the gradual increase in difficulty. I think it was easy to get a sense of the level of users who can solve each problem, and at the same time, it was just right for me to find a problem that fits my level.
-   I have solved 100 problems in brown. I have solved 100 problems in brown, and I have solved about half (55 problems) in green. I have not solved many gray puzzles.
-   While I was solving these puzzles, I started to see many of the Typical 90 puzzles on twitter, and I started to give priority to solving those puzzles.
-   As for solving problems in general, I think I am also a person who reads a lot of explanations on AC. I think that solving problems completely on your own will help you, but there is no use thinking about it all the time, so after a certain amount of time (sometimes 1 or 2 hours, sometimes a day), I would look at the explanations and move on.

#### [Competitive Pro Typical 90](https://qiita.com/e869120/items/1b2a5f0f07fd927e44e9]) [2021/06 ~ 2021/08]

-   This is a set of questions covering the most frequently encountered problems in Atcoder, as planned by [E869120](https://twitter.com/e869120).
-   For each question, an explanatory slide is prepared, which summarizes the main points in an easy-to-understand manner.
-   The questions covered are very well thought out, with no omissions or duplications. (Now I wish I had participated in the project more from the beginning.)
-   I solved the puzzles below ☆4 with priority. Especially, I couldn't solve many problems of ☆4 and ☆5 at the first time. I studied them with the intention of getting AC the next time I encountered a similar problem.
-   Recently, I think that the percentage of correct answers tends to increase when a similar problem to the 90 typical problems in the competition pro.

#### Extra: Leetcode [2020/04 ~ 2020/07

-   I solved Easy~Medium level problems, which differ from Atcoder in that the input/output method is different and you can freely run sample cases. I have the impression that there are more tree problems than in Atcoder. (On the other hand, Atcoder seems to have more high school Math IA problems.)

### Algorithms that I have already mastered at this point

The following is a list of algorithms that I have mastered at this point in time [[AtCoder] What I did to become green as an ordinary person](https://qiita.com/Kota-Y/items/396ab3c57830dad65cfb#4-%0A%20%E5%AD%A6%E3%82%93%E3%81%A0%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0).
The most recent problems using each algorithm are also included. (Some problems are not necessarily assumed solutions.)

|                     Algorizm                     | Comprehension (◎,○,△,×) |         Did you solve it during the contest? (Sample)         |
| :----------------------------------------------: | :---------------------: | :-----------------------------------------------------------: |
|               Bitwise Full Search                |            ◎            | [ABC197-C](https://atcoder.jp/contests/abc197/tasks/abc197_c) |
|                  Binary Search                   |            ○            |
|          One-dimensional cumulative sum          |            ○            |                                                               |
|          Two-dimensional cumulative sum          |            △            | [ABC215-D](https://atcoder.jp/contests/abc215/tasks/abc215_d) |
|                     GCD/LCM                      |            ◎            | [ABC215-D](https://atcoder.jp/contests/abc215/tasks/abc215_d) |
|                  Greedy Method                   |            ○            |                                                               |
|               Breadth-first search               |            ◎            | [ABC204-C](https://atcoder.jp/contests/abc204/tasks/abc204_c) |
|             Depth-first search (DFS)             |            ○            |                                                               |
|              Two-Pointer Techinique              |            ○            |                                                               |
| Dynamic Programming (DP)(Intermediate and above) |            ×            |                                                               |
|                bitDP, intervalDP                 |            ×            |                                                               |
|        Longest Incremental Sequence (LIS)        |            △            |                                                               |
|                Prioritized Queue                 |            ◎            | [ABC212-D](https://atcoder.jp/contests/abc212/tasks/abc212_d) |
|                     Dijkstra                     |            ◎            | [ABC211-D](https://atcoder.jp/contests/abc211/tasks/abc211_d) |
|                  Warchal Floyd                   |            ×            |                                                               |
|                    Union-Find                    |            ○            |                                                               |
|              Coordinate Compression              |            ○            |                                                               |

◎ is an algorithm that was solved during the contest, and ○ is an algorithm that has been implemented but not solved during the contest.
Problems that require a combination of cumulative sum and binary search may not be solvable at the current level.
I am proud to say that I can solve **easy~medium\* algorithms accurately and at a reasonable speed**, rather than being able to solve medium~difficult algorithms with a comfortable level of skill. However, it seems that there are differences among individuals in terms of strengths and weaknesses. (I am a little bad at cumulative sums...). On the other hand, I can solve width-first search, Dijkstra, and bitwise full search relatively well.)

### Library for copy and paste

During the contest, I copy and paste the util functions whenever I can use them.

#### greatest common divisor

```python
def gcd (a,b):
    """greatest common divisor of a,b, gcd
    Args:
        a (int): num
        b (int): num
    Returns:
        int : greatest common divisor of a,b
    """
    while b:
        a, b = b, a % b
    return a

```

#### least common multiple

```python
def lcm(a, b):
    """
    least common multiple of a and b
    Args:
        a (int): num
        b (int): num
    Returns:
        int : least common multiple of a,b
    """
    return a * b // gcd (a, b)
```

#### Approximate Enumeration

```python
def divisor(n):
    """Enumerate divisors of n
    Args:
        n (int): num
    Returns:
        List of divisors
    """
    i = 1
    table = []
    while i * i <= n:
        if n%i == 0:
            table.append(i)
            table.append(n//i)
        i += 1
    table = list(set(table))
    return table
```

#### prime factorization

```python
def prime_decomposition(n):
    """
    prime_decomposition(n): def prime_decomposition(n)
    Args:
        n (int): num
    Returns:
        [list]: return a list of prime factorizations of n
    """
    i = 2
    table = []
    while i * i <= n:
        while n % i == 0:
            n /= i
            table.append(i)
        i += 1
    if n > 1:
        table.append(n)
    return table
```

#### prime number determination

```python
def is_prime(n):
    """
    determine prime number
    Args:
        n ([int]): num
    Returns:
        [boolean]: True if prime, False if not prime
    """
    for i in range(2, n + 1):
        if i * i > n:
            break
        if n % i == 0:
            return False
    return n ! = 1

```

#### ncr compute

```python
from operator import mul
from functools import reduce
def ncr(n,r):
    """ncr computation (also needs import statement)

    Args:
        n ([int]]):
        r ([int]):

    Returns:
        [int]: [description].
    """
    r = min(n-r,r)
    if r == 0: return 1
    over = reduce(mul, range(n, n - r, -1))
    under = reduce(mul, range(1,r + 1))
    return over // under
```

#### Factorial calculations

```python
def factorial(n):
    """
    factorial(n): def factorial(n!
    Args:
        n ([int])):

    Returns:
        [int]: [ans].
    """
    mod = pow(10, 9) + 7
    ans = 1
    for i in range(1, n + 1):
        ans *= i
        ans %= mod
    return ans

```

Union-Find also has its own library.

### Study Methods, etc.

-   I think it is true that there is no point in doing only problems that you can solve comfortably. I think it's better to put a little bit of pressure on yourself.

I solved the following groups of problems depending on the time and day of the week.

###### Problem Groups

-   **Group 1** :Problems that can be solved with a little effort (equivalent to problems A and B) (problems with a predicted correct answer rate of 75% or higher)
-   **Group 2** :Problems that you are not sure if you can solve (your expected percentage of correct answers is between 25% and 75%).
-   **Group 3** :Problems that you may be able to come up with but are difficult to solve with your current ability (problems with less than 25% of your expected correct answers)

###### When do you solve it?

-   When I don't feel like it: **Group 1**.
-   Weekday mornings (before work):**Group 2**(If you can finish within 1h, that's good! If not, restart from the middle later)
-   On weekends, when I have more time: **Group 3** (learn the algorithms required for Group 3\*\* problems, and work on more Group 2 problems).

I was doing it in such a way.

### How to stay motivated in the competition

-   Don't work on days when you don't want to. (There are days when you are tired.)
-   Follow twitter accounts of people who are a little better than you, and add them to Atcoder's favorites.
    -   You will know what level you should aim for during the contest and when you look back.
-   People who have a large rate increase slope (in a good way) don't care.
    -   There are people in the world who raise their rates at an overwhelmingly steep angle, but in a good way, I didn't pay much attention to them. I am who I am.
-   I don't want to extend Steaks like "one question a day! I think it is better not to be conscious of increasing the number of Steaks.
    -   I think it is not good to compromise with easy problems in order to focus on this goal.
-   I am the type of person who thinks long hours and late at night when I don't understand a problem. However, when I am not able to concentrate or when my mind is not thinking straight, I often go to bed early and try to solve the problem again the next day. Sleep is important.

#### Recent ABC trends

-   I have a feeling that if I don't do my best every day, the rate will go down. (I am battling with the fear that my rate will drop if I don't solve puzzles quickly.)
-   I imagine that I have to train my ability to solve quickly and accurately (coding ability) and my typical algorithm ability on each of the two axes.
-   Should I participate in ARC?
-   Even if I participated, I felt that it would be difficult to raise the rate. I felt that even if I could solve problems appropriate to my level, I would not be able to raise my rate much. I felt that even if I participated, I couldn't start working on the problems in my stack that I should review, and the problems would accumulate in my stack. I felt that it was almost enough just to attend the (almost) weekly ABCs.

#### Do web engineers need Atcoder skills?

-   I think there are many different types of engineers, and it depends on the purpose of the engineer. However, I feel that Atcoder is rarely useful "directly" in the workplace.
    Personally, in the first year or two of my career, I wanted to improve my basic skills as an engineer, and I did it as a hobby simply because it was fun.
-   To be frank, I think there are many jobs that can be done without understanding algorithms or implementation skills. The skills required for web development are different from those acquired through Atcoder.
    On the other hand, my opinion is that the quality of code written by those who have a good understanding of algorithms may differ somewhat from that of those who do not. Especially in a language like Python, which has a rich library and can be written freely, there are many ways to write code.
    Looking around me, I have the impression that people who have a good understanding of algorithms (who have studied hard at the Faculty of Informatics) are usually excellent engineers, although the degree of their knowledge may vary. (This is not to say that those who do not are not good engineers.)
-   As a web engineer, it is essential to read other people's code and understand what they are doing.
    While playing Atcoder, you will have more opportunities to read a lot of other people's code (and it often takes you a long time to understand it because it is an algorithmic description). Through such repeated training, I feel that my code reading speed has improved. (Of course, you don't have to use Atcoder to acquire this skill.)

### Reference to the article

-   [[AtCoder] What I did to become green as an ordinary person](https://qiita.com/Kota-Y/items/396ab3c57830dad65cfb)
-   [What I did to become an AtCoder green](https://qiita.com/natsuozawa/items/0c2a0df1450612866fa2)
-   [I finally joined green at AtCoder!](https://ryusuke920.hatenablog.jp/entry/2021/04/18/170331)

### Last but not least.

-   This article contains many personal opinions.
-   I have written a lot of things, but there is a possibility that I will be dropped from AtCoder in the future (next week?). After all, this is not a perfect goal.
-   However, even though I am from a non-informatics department, I was able to become a green coder, and I have gained some confidence in my implementation skills! I have achieved my goal!
-   Thanks to the organizers and the competitive community.
-   Slow and steady wins the race!
